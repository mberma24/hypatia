/*
 * Copyright (c) 2020 ETH Zurich
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Author: Simon               2020
 */

#include <map>
#include <iostream>
#include <fstream>
#include <string>
#include <ctime>
#include <iostream>
#include <fstream>
#include <sys/stat.h>
#include <dirent.h>
#include <unistd.h>
#include <chrono>
#include <stdexcept>

#include "ns3/basic-simulation.h"
#include "ns3/tcp-flow-scheduler.h"
#include "ns3/udp-burst-scheduler.h"
#include "ns3/pingmesh-scheduler.h"
#include "ns3/topology-satellite-network.h"
#include "ns3/tcp-optimizer.h"
#include "ns3/arbiter-single-forward-helper.h"
#include "ns3/arbiter-deflection-helper.h"
#include "ns3/arbiter-gs-priority-deflection-helper.h"
#include "ns3/ipv4-arbiter-routing-helper.h"
#include "ns3/gsl-if-bandwidth-helper.h"
#include "ns3/packet-loss-counter.h"


#include "ns3/flow-monitor-helper.h"
#include "ns3/flow-monitor.h"


#include "ns3/packet.h"
#include "ns3/ipv4-header.h"
#include "ns3/ipv6-header.h"
#include "ns3/tcp-header.h"
#include "ns3/udp-header.h"
#include "ns3/point-to-point-net-device.h"
#include "ns3/ethernet-header.h"


#include "ns3/packet.h"

// Network headers
#include "ns3/ipv4-header.h"
#include "ns3/ipv6-header.h"

// Transport headers
#include "ns3/tcp-header.h"
#include "ns3/udp-header.h"

// Link / MAC headers
#include "ns3/ethernet-header.h"
#include "ns3/wifi-mac-header.h"
#include "ns3/lr-wpan-mac-header.h"
#include "ns3/sll-header.h"
#include "ns3/ppp-header.h"
#include "ns3/radiotap-header.h"
#include "ns3/aloha-noack-mac-header.h"
#include "ns3/ampdu-subframe-header.h"
#include "ns3/amsdu-subframe-header.h"

// LTE / Cellular headers
#include "ns3/lte-pdcp-header.h"
#include "ns3/lte-rlc-header.h"
#include "ns3/lte-rlc-am-header.h"
#include "ns3/epc-gtpc-header.h"
#include "ns3/epc-gtpu-header.h"
#include "ns3/epc-x2-header.h"
#include "ns3/lte-rrc-header.h"
#include "ns3/lte-asn1-header.h"

// Routing / control headers
#include "ns3/rip-header.h"
#include "ns3/ripng-header.h"
#include "ns3/arp-header.h"
#include "ns3/icmpv6-header.h"

// Application / sim-specific headers
#include "ns3/seq-ts-header.h"
#include "ns3/seq-ts-size-header.h"
#include "ns3/three-gpp-http-header.h"
#include "ns3/epc-gtpu-header.h"






using namespace ns3;
// Add these includes at the top of your file
#include "ns3/config.h"
#include "ns3/callback.h"
#include "ns3/packet.h"
#include "ns3/address.h"
#include "ns3/tcp-header.h"

// Global variables for tracking received packets
std::map<uint32_t, uint64_t> nodePacketCounts;
std::map<uint32_t, uint64_t> nodeBytesCounts;

// Callback function for successful packet reception at application layer
void OnApplicationPacketReceived(std::string path, Ptr<const Packet> packet, const Address& from)
{
    // Extract node ID from the path
    std::string nodeIdStr = path.substr(path.find("NodeList/") + 9);
    nodeIdStr = nodeIdStr.substr(0, nodeIdStr.find("/"));
    uint32_t nodeId = std::stoi(nodeIdStr);
    
    uint32_t packetSize = packet->GetSize();
    
    // Update counters
    nodePacketCounts[nodeId]++;
    nodeBytesCounts[nodeId] += packetSize;
    
    std::cout << "Node " << nodeId << " successfully received packet #" 
              << nodePacketCounts[nodeId] << " of size " << packetSize 
              << " bytes (Total: " << nodeBytesCounts[nodeId] << " bytes)" << std::endl;
}

// Alternative callback using IP layer (more reliable)
void OnIpPacketReceived(std::string path, Ptr<const Packet> packet, Ptr<Ipv4> ipv4, uint32_t interface)
{
    // Extract node ID from the path
    std::string nodeIdStr = path.substr(path.find("NodeList/") + 9);
    nodeIdStr = nodeIdStr.substr(0, nodeIdStr.find("/"));
    uint32_t nodeId = std::stoi(nodeIdStr);
    
    Ipv4Header ipv4Header;
    TcpHeader tcp;
    if (!ipv4) {
        printf("ipv4: 0, IPV4 Header: %d TCP Header: %d\n", packet->PeekHeader(ipv4Header), packet->PeekHeader(tcp));
        return;
    } else if (!packet->PeekHeader(ipv4Header)) {
        printf("ipv4: 1, IPV4 Header: 0 TCP Header: %d\n",packet->PeekHeader(tcp));
        return;
    } else if (!packet->PeekHeader(tcp)) {
        printf("ipv4: 1, IPV4 Header: 1 TCP Header: 0\n");
        return;
    }
    printf("ipv4: 1, IPV4 Header: 1 TCP Header\n");
    //uint32_t packetSize = packet->GetSize();
    uint32_t packetSize = ipv4Header.GetPayloadSize();
    
    
    // Update counters
    nodePacketCounts[nodeId]++;
    nodeBytesCounts[nodeId] += packetSize;
    
    std::cout << "Node " << nodeId << " successfully received IP packet #" 
              << nodePacketCounts[nodeId] << " of size " << packetSize 
              << " bytes (Total: " << nodeBytesCounts[nodeId] << " bytes)" << std::endl;
}

// Setup callbacks using IP layer (more reliable than application layer)
void SetupPacketReceptionCallbacks(Ptr<TopologySatelliteNetwork> topology)
{
    NodeContainer nodes = topology->GetNodes();
    
    for (uint32_t i = 0; i < nodes.GetN(); ++i) {
        uint32_t nodeId = nodes.Get(i)->GetId();

        if (!topology->IsGroundStationId(nodeId)) {
            continue;
        }
        
        // Connect to IP layer receive trace (this should always exist)
        std::ostringstream ipPath;
        ipPath << "/NodeList/" << nodeId << "/$ns3::Ipv4L3Protocol/Rx";
        try {
            Config::Connect(ipPath.str(), MakeCallback(&OnIpPacketReceived));
            std::cout << "Successfully connected callback for node " << nodeId << std::endl;
        } catch (const std::exception& e) {
            std::cout << "Failed to connect callback for node " << nodeId << ": " << e.what() << std::endl;
        }
    }
}

// Alternative: Use a scheduled callback to set up traces after applications are ready
void DelayedSetupApplicationCallbacks(Ptr<TopologySatelliteNetwork> topology)
{
    NodeContainer nodes = topology->GetNodes();
    
    for (uint32_t i = 0; i < nodes.GetN(); ++i) {
        Ptr<Node> node = nodes.Get(i);
        uint32_t nodeId = node->GetId();
        
        // Check if node has applications
        if (node->GetNApplications() > 0) {
            for (uint32_t j = 0; j < node->GetNApplications(); ++j) {
                Ptr<Application> app = node->GetApplication(j);
                
                // Try to cast to PacketSink
                Ptr<PacketSink> sink = DynamicCast<PacketSink>(app);
                if (sink) {
                    sink->TraceConnectWithoutContext("Rx", 
                        MakeBoundCallback(&OnApplicationPacketReceived, 
                                        "/NodeList/" + std::to_string(nodeId) + "/ApplicationList/" + std::to_string(j)));
                    std::cout << "Connected PacketSink callback for node " << nodeId << std::endl;
                }
            }
        }
    }
}

int main(int argc, char *argv[]) {

    // No buffering of printf
    setbuf(stdout, nullptr);

    // Retrieve run directory
    CommandLine cmd;
    std::string run_dir = "";
    cmd.Usage("Usage: ./waf --run=\"main_satnet --run_dir='<path/to/run/directory>'\"");
    cmd.AddValue("run_dir",  "Run directory", run_dir);
    cmd.Parse(argc, argv);
    if (run_dir.compare("") == 0) {
        printf("Usage: ./waf --run=\"main_satnet --run_dir='<path/to/run/directory>'\"");
        return 0;
    }

    // Load basic simulation environment
    Ptr<BasicSimulation> basicSimulation = CreateObject<BasicSimulation>(run_dir);

    // Setting socket type
    Config::SetDefault ("ns3::TcpL4Protocol::SocketType", StringValue ("ns3::" + basicSimulation->GetConfigParamOrFail("tcp_socket_type")));

    // Optimize TCP
    TcpOptimizer::OptimizeBasic(basicSimulation);

    // Read topology, and install routing arbiters
    Ptr<TopologySatelliteNetwork> topology = CreateObject<TopologySatelliteNetwork>(basicSimulation, Ipv4ArbiterRoutingHelper());

    ArbiterGSPriorityDeflectionHelper arbiterHelper(basicSimulation, topology->GetNodes());
    GslIfBandwidthHelper gslIfBandwidthHelper(basicSimulation, topology->GetNodes());

    // Schedule flows
    TcpFlowScheduler tcpFlowScheduler(basicSimulation, topology); // Requires enable_tcp_flow_scheduler=true

    // Schedule UDP bursts
    UdpBurstScheduler udpBurstScheduler(basicSimulation, topology); // Requires enable_udp_burst_scheduler=true

    // Schedule pings
    PingmeshScheduler pingmeshScheduler(basicSimulation, topology); // Requires enable_pingmesh_scheduler=true

    std::srand(std::time(nullptr));

    // IMPORTANT: Set up packet reception callbacks AFTER applications are installed
    // Use IP layer callbacks (more reliable) or schedule application callbacks for later
    
    // Option 1: IP layer callbacks (recommended - always works)
    SetupPacketReceptionCallbacks(topology);
    
    // Option 2: If you specifically want application-layer callbacks, schedule them after simulation starts
    // Simulator::Schedule(Seconds(0.1), &DelayedSetupApplicationCallbacks, topology);

    // Run simulation
    basicSimulation->Run();

    // Write flow results
    tcpFlowScheduler.WriteResults();

    // Write UDP burst results
    udpBurstScheduler.WriteResults();

    // Write pingmesh results
    pingmeshScheduler.WriteResults();

    // Collect utilization statistics
    topology->CollectUtilizationStatistics();

    // Finalize the simulation
    basicSimulation->Finalize();

    printf("\n\nLOGGING RESULTS\n");
   

    // Print packet reception statistics
    printf("\n\nPACKET RECEPTION STATISTICS\n");
    for (auto it = nodePacketCounts.begin(); it != nodePacketCounts.end(); it++) {
        std::cout << "Node " << it->first << ": " << it->second << " packets, " 
                  << double(nodeBytesCounts[it->first]) * 8 / 1000000  << " mbits" << std::endl;
    }

    return 0;
}

// uint32_t GetPayloadSize(Ptr<const Packet> pkt)
// {
    
//     // Make a copy to avoid modifying the original packet
//     Packet pktCopy = *pkt;

//         // Network headers
//     Ipv4Header ipv4; if (pktCopy.PeekHeader(ipv4)) pktCopy.RemoveHeader(ipv4);
//     Ipv6Header ipv6; if (pktCopy.PeekHeader(ipv6)) pktCopy.RemoveHeader(ipv6);

//     // Transport headers
//     TcpHeader tcp; if (pktCopy.PeekHeader(tcp)) pktCopy.RemoveHeader(tcp);
//     UdpHeader udp; if (pktCopy.PeekHeader(udp)) pktCopy.RemoveHeader(udp);

//     // // Link/MAC headers
//     //EthernetHeader eth; if (pktCopy.PeekHeader(eth)) pktCopy.RemoveHeader(eth);
//     // WifiMacHeader wifi; if (pktCopy.PeekHeader(wifi)) pktCopy.RemoveHeader(wifi);
//     // LrWpanMacHeader lrwpan; if (pktCopy.PeekHeader(lrwpan)) pktCopy.RemoveHeader(lrwpan);
//     // SllHeader sll; if (pktCopy.PeekHeader(sll)) pktCopy.RemoveHeader(sll);
//     // PppHeader ppp; if (pktCopy.PeekHeader(ppp)) pktCopy.RemoveHeader(ppp);
//     // RadiotapHeader rtap; if (pktCopy.PeekHeader(rtap)) pktCopy.RemoveHeader(rtap);
//     // AlohaNoackMacHeader aloha; if (pktCopy.PeekHeader(aloha)) pktCopy.RemoveHeader(aloha);
//     // AmpduSubframeHeader ampdu; if (pktCopy.PeekHeader(ampdu)) pktCopy.RemoveHeader(ampdu);
//     // AmsduSubframeHeader amsdu; if (pktCopy.PeekHeader(amsdu)) pktCopy.RemoveHeader(amsdu);

//     // // LTE / Cellular headers
//     // LtePdcpHeader pdcp; if (pktCopy.PeekHeader(pdcp)) pktCopy.RemoveHeader(pdcp);
//     // LteRlcHeader rlc; if (pktCopy.PeekHeader(rlc)) pktCopy.RemoveHeader(rlc);
//     // LteRlcAmHeader rlcAm; if (pktCopy.PeekHeader(rlcAm)) pktCopy.RemoveHeader(rlcAm);

//     // // GTP headers (if concrete)
//     // GtpcHeader gtpc; if (pktCopy.PeekHeader(gtpc)) pktCopy.RemoveHeader(gtpc);
//     // GtpuHeader gtpu; if (pktCopy.PeekHeader(gtpu)) pktCopy.RemoveHeader(gtpu);
//     // EpcX2Header x2; if (pktCopy.PeekHeader(x2)) pktCopy.RemoveHeader(x2);

//     // // Routing/control headers
//     // RipHeader rip; if (pktCopy.PeekHeader(rip)) pktCopy.RemoveHeader(rip);
//     // RipNgHeader ripng; if (pktCopy.PeekHeader(ripng)) pktCopy.RemoveHeader(ripng);
//     // ArpHeader arp; if (pktCopy.PeekHeader(arp)) pktCopy.RemoveHeader(arp);
//     // Icmpv6Header icmpv6; if (pktCopy.PeekHeader(icmpv6)) pktCopy.RemoveHeader(icmpv6);

//     // // Application / sim-specific headers
//     // SeqTsHeader seqts; if (pktCopy.PeekHeader(seqts)) pktCopy.RemoveHeader(seqts);
//     // SeqTsSizeHeader seqsize; if (pktCopy.PeekHeader(seqsize)) pktCopy.RemoveHeader(seqsize);
//     // ThreeGppHttpHeader http; if (pktCopy.PeekHeader(http)) pktCopy.RemoveHeader(http);


//     // Return remaining size (application payload)
//     return pktCopy.GetSize();
// }


// static void PhyRxCallback(Ptr<TopologySatelliteNetwork> topo,
//                           std::string context,
//                           Ptr<const Packet> pkt)
// {
//     // Extract node number from context as before
//     uint32_t nodeId = 0;
//     size_t pos1 = context.find("/NodeList/");
//     if (pos1 != std::string::npos) {
//         pos1 += 10;
//         size_t pos2 = context.find("/", pos1);
//         if (pos2 != std::string::npos) {
//             nodeId = std::stoul(context.substr(pos1, pos2 - pos1));
//         }
//     }

//     // You can also access topology info
//     auto node = topo->GetNodes().Get(nodeId);
//     if (topo->IsGroundStationId(nodeId)) {
//         std::cout << context << std::endl;
//         uint32_t ogSize = pkt->GetSize(); // fallback
//         int32_t newSize = GetPayloadSize(pkt->Copy());

        
       
//         if (full.find(nodeId) == full.end()) {
//             full[nodeId] = ogSize;
//             pay[nodeId] = newSize;
//         } else {
//             full[nodeId] += ogSize;
//             pay[nodeId] += newSize;
//         }
//     }

//     // Do something with the node or topology
// }